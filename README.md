# Триангуляция Делоне 
***Формулировка задачи:*** по заданному множеству точек на плоскости построить триангуляцию, удовлетворяющую условию Делоне.

## Конечный результат
1. *Библиотека delaunayTriangulation*, содержащая функцию *getTriangulation()*, которая будет возвращать
вектор из треугольников, составляющих построенную триангуляцию.
2. *Консольное приложение*, визуализирующее построенную триангуляцию. Будет принимать на вход координаты
точек(пары действительных чисел) и на выходе будет давать изображение построенной триангуляции. 
Инструмент для визуализации - библиотека **OpenCV**\
__Входные данные(вводятся в консоль)__ \
  x1 y1 \
  x2 y2 \
  ... \
  xn yn \
__Примерный результат работы консольного приложения:__ \
![example](Example.PNG)

---
## Используемый алгоритм: алгоритм Боуэра-Ватсона.
1. Шаги алгоритма:
- Cоздание супер-треугольника, внутрь которого попадают все заданные точки.
- Итеративное добавление каждой точки. Для каждой точки мы рассматриваем все треугольники, окружности которых содержат точку, и называем их "плохими треугольниками".
- Для каждого *плохого* треугольника удаляем те рёбра, которые являются общими для других *плохих* треугольников. То есть оставляем только уникальные ребра плохих треугольников.
- Строим треугольники из добавленной точки и оставшихся рёбер *плохих* треугольников.
- Повторяем даные шаги для всех точек набора.
- Удаляем треугольники, которые содержат точки супер-треугольника.
2. Структуры данных: 
```c++
struct Point {
	double x_ = 0;
	double y_ = 0;
};

struct Edge {
	Point* A_;
	Point* B_;

	bool good = true;
	bool super = false;
}

struct Triangle {
	Point* A_;
	Point* B_; 
	Point* C_;
	Edge AB_;
	Edge BC_;
	Edge AC_;
	int count_bad = 0;// Если вдруг треугольник станет "плохим", то это будет количество его "плохих" соседей
};
```

